---
title: 'Part 3 - The OAuth Authorization Server'
published: 2025-08-01
draft: false
description: 'Learning about the OAuth Authorization Server from the authorization grant type'
tags: ['OAuth']
series: 'OAuth Simplified'
---

## 1 Introduction

:::me
In this section, there will be a deep dive into a very simple implementation of the OAuth Authorization server.
:::

:::joyfulDuck
Great! I hope I learn a lot.
:::

:::strongme
I'm sure you will. Let's do this!
:::

The authorization server that will be discussed supports the authorization code grant type has the following features:

- Registers clients.
- Issues tokens to clients.
- Assigns a scope to an issued token.
- Issues refresh tokens to clients.
- Authenticates users.

Because of the vast amount of features the authorization server must support, it is arguably the most complex component in the OAuth ecosystem.

**1.2** In the OAuth protocol, most complexity is pushed to the authorization server because authorization servers are the fewest in number. This means there are many more clients than protected resources, and there are many more protected resources than authorization servers.

:::me
Let's now step through the process of creating an authorization server.
:::

## 2 Registering a Client

**2.1** As a first step, the authorization server must register clients on it's database. The simplest form of managing clients on the authorization server is static registration. This means the authorization server **generates** all the unique client identifiers (client IDs) needed for all clients that connect to the authorization server. The clients would be stored in a database on a production-level authorization server.

**2.2** Once the client IDs are defined, the authorization server **generates** a client secret for each client. This secret is also stored in the database for production-level authorization servers. the client secret will be stored alongside the client ID in the database.

**2.3** The final step in registering a client is to define a redirect URI. Unlike the client ID and the client secret, the authorization server **does not generate** the redirect URI. The redirect URI is defined by the client.

:::confusedDuck
Wait.... if the redirect URI is not generated by the authorization server and comes from the client, then how does the client send it's redirect URI to the authorization server? The connection between the client and the authorization server is not established yet.
:::

:::me
To keep things simple in our example, the redirect URI will be manually entered into the authorization server. We will discuss the purpose and use of the Redirect URI very soon!
:::

At the end of the client registration process, the authorization server would have a client object like this in it's database:

```JSON
{
  "client_id": "oauth-client-1",
  "client_secret": "oauth-client-secret-1",
  "redirect_uris": ["http://client-server:9000/callback"],
}
```

There could be many objects like this and all of them would be stored on the database of the authorization server.

## 3 Authorizing a Client

<!-- TODO: Create a blog for front-channel and back-channel communcation -->

:::strongme
Our authorization server is now ready to accept client authorization requests.
:::

**3.1** As discussed, the authorization server needs to authorize the client on behalf of the user so the client can receive an authorization code. This communication is done over the front-channel, which needs to be reachable by the user's browser. Since most authorization servers are web servers, the authorization endpoint typically has the `/authorize` path and is always a `GET` request.

:::me
Let's say a test client is trying to get authorized from our authorization server. The following flow will occur.
:::

**3.2** Firstly, when the test client calls the `/authorize` endpoint, the authorization server finds out which client made the request. Typically, the client passes its identifier in the `client_id` parameter and its redirect URI in the `redirect_uri` parameter.

**3.3** Once the `client_id` has been parsed by the authorization server, the authorization server must determine if the client exists in its database of predefined clients. If the client does not exist, an error is emitted such as `{error: 'Unknown client'}`. A classic check is to see if the `client_id` and `redirect_uri` that was passed in by the client, match what is already stored in the authorization server's database. Since only checking the `client_id` could lead to security gaps. The check for the `redirect_uri` is highly recommended because all the current communication in this section is being done on the public front-channel, which can be easily tampered with.

The client sends the following payload to the authorization server:

```JSON
{
  "client_id": "oauth-client-1",
  "client_secret": "oauth-client-secret-1",
  "redirect_uris": ["http://client-server:9000/callback"],
}
```

:::note
According to the OAuth specification, a client can register multiple redirect URIs for itself, allowing the client to be served from different URLs in different circumstances. This is why the `redirect_uris` in the payload above is being treated as an array.
:::
**3.4** When the client is authorized, a `request_id` is randomly generated to keep track of the client's initial authorization request. As we will see in the next step, this `request_id` will protect the server from cross-site request forgery. Also, this `request_id` will get stored in the authorization server's database alongside the specific client's information that sent the initial authorization request to receive the authorization code.

The database will have the following data at the end of this client verification flow:

```JSON
{
  "client_id": "oauth-client-1",
  "client_secret": "oauth-client-secret-1",
  "redirect_uris": ["http://client-server:9000/callback"],
  "request_id": 324
}
```

:::magnifyingglassme
Here is a full video walkthrough of the entire flow mentioned in this section
:::

<video src="https://github.com/user-attachments/assets/cac24de2-9bc2-45e3-8e5b-4fea99a53004" controls autoplay loop muted></video>
Figure 3 - Shows the client authorization flow.

**3.5** The client is now authorized, with its request ID safely stored in the authorization server's database. The next stage prompts the user to authorize the client on the user's behalf. This is done so the request ID from the form can be validated with the request ID from the initial request by the client.

:::joyfulDuck
Woohoo! Our external test client is now verified against the predefined set of clients in the authorization server's database! I'm excited to see what further steps we have in the OAuth authorization code grant type.
:::

## 4 User Decision

**4.1** After the client is authorized, the user is prompted to give the client the relevant permissions to access the protected resource and act on the user's behalf. This can be done through a form using a UI. Here is an example:</br>

<fieldset>
Approve this Client?</br>
ID: `test-client`
    <select>
        <option value="1">Approve</option>
        <option value="2">Reject</option>
    </select><br>
    <button type="submi">Submit</button>
</fieldset>

**4.2** The user can approve or reject the client who requested to be authorized and act on behalf of the user. After clicking the `Submit` button, an API request is typically sent to the endpoint path `/approve` on the authorization server.

:::warning
The OAuth 2.0 protocol does not care if the user is **authenticated** when the authorization server prompts the user to authorize the client. User authentication is entirely outside the scope of OAuth 2.0. This is why adequate care is required to supply user authentication at this stage.</br>
:::

**4.3** The `request ID` from the client in the previous section is embedded into this form in the background. So when the user clicks on Submit, the `request ID` is included into the API call to`/approve` in the authorization server. The authorization server will compare the request ID from the form to what is stored in it's database for added security. Here is the full object that is sent to the `/approve` endpoint path:

```JSON
{
  "client_id": "oauth-client-1",
  "client_secret": "oauth-client-secret-1",
  "redirect_uris": ["http://client-server:9000/callback"],
}
```

## 5 Processing the User Decision

:::confusedDuck
So, what happens if the user rejects the client?
:::

**5.1** If the user **rejects** the client, by calling `/approve` with the `reject` message, this means the user has denied access to an otherwise valid client. The authorization server now has the responsibility to tell the client that the user has rejected its authorization request. This can be done the same way as the client communicated with the authorization server. Meaning, the authorization server will take a URL hosted by the client, add a few special query parameters, and redirect the user to the endpoint defined by the client's `redirect_uri`. The URL that is hosted by the client, which the authorization server can use is known as the `redirect_uri`. The authorization server sends back an error message to the `redirect_uri` with the message `error: access_denied`.

**5.2** This is why the client's `redirect_uri` is needed. Also, this is why the authorization server validated the client's `redirect_uri` against the existing client information in the authorization server's database when the initial authorization request arrived by the client. So the authorization server knows that it is sending the user to an approved,verified address. And not an address that can be tampered with through the front-channel.

:::confusedDuck
Hmm.. Interesting! Now I understand the purpose of the Redirect URI. What happens if the user approves the client?
:::
**5.3** If the user has **approved** the client, then this means the user allows the client to act on their behalf.</br>
When the `/approve` is called withÂ the `approve` message, the first step is to check what kind of response the client seeks. The HTTP `response_type` should be `code`. If not, error is sent to the `redirect_uri`.</br>
The second step is to generate the authorization code and save it into the database because the authorization code will need to be referenced by the authorization server for later steps as we will see.</br>
Finally, the third step is to send back the authorization code, and the `scope` (if provided by the client in the initial authorization request) to the client through the client's `redirect_uri` and hand back control to the client. The authorization server is now fully prepared for the next step in the OAuth 2.0 authorization code grant type flow.

## 6 Issuing a Token

**6.1** At this point the client is now in control and has the authorization code that was received from the front-channel by the authorization server. The next step is to request an authorization token by sending a `POST` request to the `/authorize` endpoint of authorization server. The client can seend the code either in the header or the form body. Well behaved authorization servers would accept either methods but not both at the same time.

**6.2** When the `/authorize` endpoint is called, the authorization server will validate the following in order by comparing the incoming data from the client to what is already stored in the authorization server's database:

- The client ID
- The client secret
- The authorization code

:::note
Once the authorization code is validated, it is saved inside a variable at runtime and is deleted from the database. This is to prevent the use of a stolen authorization code and err on the side of caution.
:::

**6.3** When all the relevant data is validated, the next step is to check if the `grant_type` is set to `authorization_code` in the body of the `POST` request sent by the client. Since the authorization server in this case only supports the authorization code flow grant type, it is important to check.

**6.4** If the authorization server does find the authorization code grant, the authorization server then needs to generate an **authorization token**. OAuth 2.0 is famously silent about what is inside an authorization token. It is up to you to add whatever content you want inside the authorization token. For example, you can create a JWT token. But for this case, we will keep things simple and generate a random string, then store it in the database.

**6.5** Now the authorization server can finally send the token back to the client in the form of a JSON object that includes the authorization token. The JSON object should also include how the protected resource can use the authorization token. The usage method of the authorization token can be communicated by specifying the type of the authorization token. In this case, the authorization server sends back a `Bearer` token:

```JSON
{
  "access_toke": "lRQUChwvWf",
  "token_type": "Bearer"
}
```

**6.7** At this point, we have stepped through a simple but fully functioning authorization server:

- Authenticating clients
- Prompting users for authorization
- Issuing randomized bearer tokens using the authorization code flow.

Nice! :rocket:

The next steps can be seen as optional added features to the authorization server.

## Scope

<fieldset>
Approve this Client?</br>
ID: `test-client`
    <select>
        <option value="1">Approve</option>
        <option value="2">Reject</option>
    </select><br>
    <label><input type="checkbox"> read<br></label>
    <label><input type="checkbox"> write<br></label>
    <label><input type="checkbox"> delete<br></label>
    <button type="submi">Submit</button>
</fieldset>

You can see that the user can give the client fine-grained permissions by providing the client with read, write, or delete permissions. These permissions are added in the scope section when the token is issued in later steps.
